
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>atmcs: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/dragonzurfer/trader/atmcs/atmcs.go (70.3%)</option>
				
				<option value="file1">github.com/dragonzurfer/trader/atmcs/candleadapter.go (87.5%)</option>
				
				<option value="file2">github.com/dragonzurfer/trader/atmcs/entry.go (80.5%)</option>
				
				<option value="file3">github.com/dragonzurfer/trader/atmcs/entrysatisfy.go (78.9%)</option>
				
				<option value="file4">github.com/dragonzurfer/trader/atmcs/exit.go (80.0%)</option>
				
				<option value="file5">github.com/dragonzurfer/trader/atmcs/housekeeping.go (0.0%)</option>
				
				<option value="file6">github.com/dragonzurfer/trader/atmcs/loadtradejson.go (76.2%)</option>
				
				<option value="file7">github.com/dragonzurfer/trader/atmcs/satisfyexit.go (84.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package atmcs

import (
        "encoding/json"
        "io/ioutil"
        "log"
        "time"

        cpr "github.com/dragonzurfer/strategy/CPR"
        "github.com/dragonzurfer/trader/atmcs/trade"
        "github.com/dragonzurfer/trader/executor"
)

type ATMcs struct {
        ISTLocation    *time.Location `json:"-"`
        SignalCPR      cpr.Signal
        EntrySatisfied bool
        ExitSatisfied  bool
        Broker         executor.BrokerLike
        EntryMessage   string
        ExitMessage    string
        Trade          trade.Trade
        Settings
        SettingsFilesPath string
        GetCurrentTime    func() time.Time `json:"-"`
        Holidays
        StopLossHitChan chan bool `json:"-"`
        TargetHitChan   chan bool `json:"-"`
}

type DurationWrapper struct {
        time.Duration
}
type Settings struct {
        HolidayDatesFilePath string          `json:"holidays_file_path"`
        MinTrailPercent      float64         `json:"min_trail_percent"`
        MinTargetPercent     float64         `json:"min_target_percent"`
        MinStopLossPercent   float64         `json:"min_sl_percent"`
        TradeFilePath        string          `json:"tradeFilePath"`
        Quantity             int64           `json:"quantity"`
        StrikeDiff           float64         `json:"strikeDiff"`
        MinDaysToExpiry      int64           `json:"minDaysToExpiry"`
        Symbol               string          `json:"symbol"`
        TickSize             float64         `json:"tick_size"`
        SleepDuration        DurationWrapper `json:"sleep_duration"`
}

func (d *DurationWrapper) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        var durationStr string
        err := json.Unmarshal(data, &amp;durationStr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">duration, err := time.ParseDuration(durationStr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">d.Duration = duration
        return nil</span>
}

func (obj *ATMcs) loadSettingsFromFile() error <span class="cov8" title="1">{
        var settings Settings

        // Read the JSON file
        fileData, err := ioutil.ReadFile(obj.SettingsFilesPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Unmarshal the JSON data into the Settings struct
        <span class="cov8" title="1">err = json.Unmarshal(fileData, &amp;settings)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">obj.Settings = settings
        return nil</span>
}

func (obj *ATMcs) SetBroker(broker executor.BrokerLike) <span class="cov8" title="1">{
        obj.Broker = broker
}</span>

func (obj *ATMcs) SetTradeFilePath(filepath string) <span class="cov8" title="1">{
        obj.TradeFilePath = filepath
}</span>

func (obj *ATMcs) SetSettingsFilesPath(filepath string) <span class="cov8" title="1">{
        obj.SettingsFilesPath = filepath
}</span>

func (obj *ATMcs) InTradingWindow() bool <span class="cov8" title="1">{
        now := obj.GetCurrentTime()
        start := time.Date(now.Year(), now.Month(), now.Day(), 9, 14, 0, 0, obj.ISTLocation)
        end := time.Date(now.Year(), now.Month(), now.Day(), 15, 16, 0, 0, obj.ISTLocation)
        // fmt.Printf("%v\n%v\n%v\n", start, end, now)
        if now.After(start) &amp;&amp; now.Before(end) </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

func (obj *ATMcs) IsError() bool <span class="cov0" title="0">{
        return false
}</span>
func (obj *ATMcs) ReadErrors() []string <span class="cov0" title="0">{
        return []string{}
}</span>
func (obj *ATMcs) GetSleepDuration() time.Duration <span class="cov8" title="1">{
        return obj.SleepDuration.Duration
}</span>

func (obj *ATMcs) LoadLocation() error <span class="cov8" title="1">{
        istLocation, err := time.LoadLocation("Asia/Kolkata")
        obj.ISTLocation = istLocation
        return err
}</span>

func (obj *ATMcs) LoadHolidays() error <span class="cov8" title="1">{
        holidaysData, err := ioutil.ReadFile(obj.HolidayDatesFilePath)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Error reading holidays file:", err)
                return err
        }</span>

        <span class="cov8" title="1">var holidays Holidays
        err = json.Unmarshal(holidaysData, &amp;holidays)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Error unmarshaling holidays data:", err)
                return err
        }</span>
        <span class="cov8" title="1">obj.Holidays = holidays
        return nil</span>
}

func (obj *ATMcs) AccountTrade(executor.TradeType) {<span class="cov0" title="0">

}</span>

func (obj *ATMcs) GetTradeType() executor.TradeType <span class="cov8" title="1">{
        return obj.Trade.TradeType
}</span>

func (obj *ATMcs) GetStopLossHitChan() &lt;-chan bool <span class="cov8" title="1">{
        return obj.StopLossHitChan
}</span>

func (obj *ATMcs) GetTargetHitChan() &lt;-chan bool <span class="cov8" title="1">{
        return obj.TargetHitChan
}</span>

func New(settingsFilePath string, currentTimeFunc func() time.Time) *ATMcs <span class="cov8" title="1">{
        var obj ATMcs
        obj.SetSettingsFilesPath(settingsFilePath)

        if err := obj.loadSettingsFromFile(); err != nil </span><span class="cov0" title="0">{
                log.Println("error SetSettingsFIlesPath(string) failed to load settings from: %w", obj.SettingsFilesPath, err)
                return nil
        }</span>
        <span class="cov8" title="1">if err := obj.LoadHolidays(); err != nil </span><span class="cov0" title="0">{
                log.Printf("error LoadHolidays() file from %+v:%v\n", obj.Settings.HolidayDatesFilePath, err.Error())
                return nil
        }</span>
        <span class="cov8" title="1">if err := obj.LoadLocation(); err != nil </span><span class="cov0" title="0">{
                log.Println("error loading ist location:", err.Error())
                return nil
        }</span>
        <span class="cov8" title="1">if obj.Settings.TickSize &lt;= 0 </span><span class="cov0" title="0">{
                log.Println("error loading tick size, cannot be &lt;= 0")
                return nil
        }</span>
        <span class="cov8" title="1">if obj.Settings.MinTargetPercent &lt; obj.Settings.MinTrailPercent </span><span class="cov0" title="0">{
                log.Println("min target cananot be lesser than min trail in settings")
                return nil
        }</span>
        <span class="cov8" title="1">obj.SetTradeFilePath(obj.Settings.TradeFilePath)
        if err := obj.LoadFromJSON(); err != nil </span><span class="cov0" title="0">{
                log.Println("error LoadTradeFromJSON() loading trade from JSON:", err.Error())
                return nil
        }</span>

        <span class="cov8" title="1">obj.StopLossHitChan = make(chan bool)
        obj.TargetHitChan = make(chan bool)
        obj.GetCurrentTime = currentTimeFunc
        obj.EntrySatisfied = false
        obj.ExitSatisfied = false
        return &amp;obj</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package atmcs

import (
        "github.com/dragonzurfer/revclose"
        "github.com/dragonzurfer/trader/executor"
)

type CandleAdapter struct {
        candles []executor.CandleLike
}

type RevCandleAdapter struct {
        candle executor.CandleLike
}

func (rca *RevCandleAdapter) GetHigh() float64 <span class="cov8" title="1">{
        return rca.candle.GetHigh()
}</span>

func (rca *RevCandleAdapter) GetLow() float64 <span class="cov8" title="1">{
        return rca.candle.GetLow()
}</span>

func (rca *RevCandleAdapter) GetClose() float64 <span class="cov8" title="1">{
        return rca.candle.GetClose()
}</span>

func (rca *RevCandleAdapter) GetOpen() float64 <span class="cov0" title="0">{
        return rca.candle.GetOpen()
}</span>

func (rca *RevCandleAdapter) GetOHLC() (float64, float64, float64, float64) <span class="cov8" title="1">{
        return rca.candle.GetOpen(), rca.candle.GetHigh(), rca.candle.GetLow(), rca.candle.GetClose()
}</span>

func (ca *CandleAdapter) GetCandle(index int) revclose.RevCandle <span class="cov8" title="1">{
        return &amp;RevCandleAdapter{candle: ca.candles[index]}
}</span>

func (ca *CandleAdapter) GetCandlesLength() int <span class="cov8" title="1">{
        return len(ca.candles)
}</span>

func NewCandleAdapter(candles []executor.CandleLike) *CandleAdapter <span class="cov8" title="1">{
        return &amp;CandleAdapter{
                candles: candles,
        }
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package atmcs

import (
        "errors"
        "fmt"
        "log"
        "math"
        "strconv"
        "strings"
        "time"

        "github.com/dragonzurfer/trader/atmcs/trade"
        "github.com/dragonzurfer/trader/executor"
)

func (obj *ATMcs) PaperTrade(tradeType executor.TradeType) <span class="cov8" title="1">{
        obj.Trade.InTrade = true
        obj.Trade.EntryPositions = obj.makeEntryPositions(tradeType)
        obj.Trade.TimeOfEntry = obj.GetCurrentTime()
}</span>

func (obj *ATMcs) makeEntryPositions(tradeType executor.TradeType) []trade.OptionPosition <span class="cov8" title="1">{

        ltp, err := obj.Broker.GetLTP(obj.Symbol)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err.Error())
                return nil
        }</span>

        <span class="cov8" title="1">strike := GetNearest100ITMStrike(ltp, tradeType)

        expiries, err := obj.Broker.GetOptionExpiries(obj.Symbol)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err.Error())
                return nil
        }</span>

        <span class="cov8" title="1">sellExpiry, err := GetExpiry(obj.GetCurrentTime(), obj.MinDaysToExpiry, strike, expiries)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err.Error())
                return nil
        }</span>

        <span class="cov8" title="1">buyExpiry, err := GetMonthlyExpiryCalendarSpread(obj.GetCurrentTime(), sellExpiry.ExpiryDate, expiries)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err.Error())
                return nil
        }</span>

        <span class="cov8" title="1">symbol := obj.Symbol

        quantity := obj.Quantity
        var sellPosition, buyPosition trade.OptionPosition
        var entryPositions []trade.OptionPosition
        if tradeType == executor.Buy </span><span class="cov8" title="1">{
                sellPosition = obj.MakeEntryPosition(symbol, strike, sellExpiry, executor.PutOption, executor.Sell, quantity)
                buyPosition = obj.MakeEntryPosition(symbol, strike, buyExpiry, executor.PutOption, executor.Buy, quantity/2)
        }</span> else<span class="cov8" title="1"> {
                sellPosition = obj.MakeEntryPosition(symbol, strike, sellExpiry, executor.CallOption, executor.Sell, quantity)
                buyPosition = obj.MakeEntryPosition(symbol, strike, buyExpiry, executor.CallOption, executor.Buy, quantity/2)
        }</span>
        <span class="cov8" title="1">bids, err := GetBids(obj.Broker, sellPosition)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err.Error())
                return nil
        }</span>
        <span class="cov8" title="1">asks, err := GetAsks(obj.Broker, buyPosition)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err.Error())
                return nil
        }</span>
        <span class="cov8" title="1">sellPosition.Price = obj.GetAvgMarketDepth(bids)
        buyPosition.Price = obj.GetAvgMarketDepth(asks)
        entryPositions = append(entryPositions, sellPosition, buyPosition)
        return entryPositions</span>
}

func (obj *ATMcs) MakeEntryPosition(symbol string, strike float64, expiry executor.Expiry, optionType executor.OptionType, tradeType executor.TradeType, quantity int64) trade.OptionPosition <span class="cov8" title="1">{
        option := trade.Option{
                Strike:           strike,
                Expiry:           expiry.ExpiryDate,
                Type:             optionType,
                Symbol:           obj.Symbol, //change to broker symbol
                UnderlyingSymbol: symbol,
        }
        optionPosition := trade.OptionPosition{
                Option:    option,
                TradeType: tradeType,
                Quantity:  quantity,
        }
        return optionPosition
}</span>

func (obj *ATMcs) GetAvgMarketDepth(depth []executor.MarketDepthLike) float64 <span class="cov8" title="1">{
        if len(depth) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">total := 0.0
        totalVolumeOrders := 0.0
        for _, marketDepth := range depth </span><span class="cov8" title="1">{
                volumeOrders := float64(marketDepth.GetQuantity() * marketDepth.GetNumOfOrders())
                total += marketDepth.GetPrice() * volumeOrders
                totalVolumeOrders += volumeOrders
        }</span>

        <span class="cov8" title="1">if totalVolumeOrders == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">avgPrice := total / totalVolumeOrders
        roundedPrice := roundToNearest(avgPrice, obj.Settings.TickSize)
        if roundedPrice &lt; avgPrice </span><span class="cov8" title="1">{
                roundedPrice += obj.Settings.TickSize
        }</span>
        <span class="cov8" title="1">decimalPlaces := countDecimalPlaces(obj.Settings.TickSize)
        roundedPrice = truncateDecimal(roundedPrice, decimalPlaces)
        return roundedPrice</span>
}

func GetBids(broker executor.BrokerLike, pos trade.OptionPosition) ([]executor.MarketDepthLike, error) <span class="cov8" title="1">{
        bid_aks, err := broker.GetMarketDepthOption(pos.Strike, pos.Expiry, pos.Type)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return bid_aks.GetBids(), err</span>
}

func GetAsks(broker executor.BrokerLike, pos trade.OptionPosition) ([]executor.MarketDepthLike, error) <span class="cov8" title="1">{
        bid_aks, err := broker.GetMarketDepthOption(pos.Strike, pos.Expiry, pos.Type)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return bid_aks.GetAsks(), err</span>
}

func GetExpiry(currentTime time.Time, minDaysToExpiry int64, strike float64, expiries []executor.Expiry) (executor.Expiry, error) <span class="cov8" title="1">{
        var err error
        err = fmt.Errorf("could not find an expiry that has %v days to expiry", minDaysToExpiry)
        minDiff := int64(math.MaxInt64)
        var earliestExpiry executor.Expiry
        for _, expiry := range expiries </span><span class="cov8" title="1">{
                daysDiff := int64(expiry.ExpiryDate.Sub(currentTime).Hours() / 24)
                if daysDiff &gt;= minDaysToExpiry &amp;&amp; daysDiff &lt; minDiff </span><span class="cov8" title="1">{
                        minDiff = daysDiff
                        earliestExpiry = expiry
                        err = nil
                }</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("could not find an expiry that has %v days to expiry: found expiry(%v) with %v days to expiry", minDaysToExpiry, earliestExpiry, minDiff)
        }</span>

        <span class="cov8" title="1">return earliestExpiry, err</span>
}

func GetMonthlyExpiryCalendarSpread(currentTime time.Time, sellExpiry time.Time, expiries []executor.Expiry) (executor.Expiry, error) <span class="cov8" title="1">{
        currentYear, currentMonth := currentTime.Year(), currentTime.Month()

        var lastExpiryOfCurrentMonth executor.Expiry
        var lastExpiryOfNextMonth executor.Expiry
        var foundCurrentMonth, foundNextMonth bool

        nextMonth := currentMonth + 1
        nextYear := currentYear

        if nextMonth &gt; 12 </span><span class="cov8" title="1">{
                nextMonth = 1
                nextYear++
        }</span>
        <span class="cov8" title="1">for _, expiry := range expiries </span><span class="cov8" title="1">{
                if expiry.ExpiryDate.After(sellExpiry) </span><span class="cov8" title="1">{

                        expiryYear, expiryMonth := expiry.ExpiryDate.Year(), expiry.ExpiryDate.Month()

                        if expiryYear == currentYear &amp;&amp; expiryMonth == currentMonth </span><span class="cov8" title="1">{
                                lastExpiryOfCurrentMonth = expiry
                                foundCurrentMonth = true
                        }</span> else<span class="cov8" title="1"> if expiryYear == nextYear &amp;&amp; expiryMonth == nextMonth </span><span class="cov8" title="1">{
                                lastExpiryOfNextMonth = expiry
                                foundNextMonth = true
                        }</span> else<span class="cov0" title="0"> if expiryYear &gt; nextYear || (expiryYear == nextYear &amp;&amp; expiryMonth &gt; nextMonth) </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">if foundCurrentMonth </span><span class="cov8" title="1">{
                return lastExpiryOfCurrentMonth, nil
        }</span> else<span class="cov8" title="1"> if foundNextMonth </span><span class="cov8" title="1">{
                return lastExpiryOfNextMonth, nil
        }</span> else<span class="cov0" title="0"> {
                return executor.Expiry{}, errors.New("no suitable monthly expiry found")
        }</span>
}

func GetNearest100ITMStrike(ltp float64, tradeType executor.TradeType) float64 <span class="cov8" title="1">{
        closest100Multiple := roundToNearest(ltp, 100)

        switch tradeType </span>{
        case executor.Buy:<span class="cov8" title="1">
                if closest100Multiple &lt; ltp </span><span class="cov8" title="1">{
                        return closest100Multiple + 100
                }</span>
                <span class="cov0" title="0">return closest100Multiple</span>
        case executor.Sell:<span class="cov8" title="1">
                if closest100Multiple &gt; ltp </span><span class="cov0" title="0">{
                        return closest100Multiple - 100
                }</span>
                <span class="cov8" title="1">return closest100Multiple</span>
        }
        <span class="cov0" title="0">return closest100Multiple</span>
}

func roundToNearest(val, roundTo float64) float64 <span class="cov8" title="1">{
        if roundTo == 0 </span><span class="cov0" title="0">{
                return val
        }</span>
        <span class="cov8" title="1">rounded := roundTo * float64(int(val/roundTo))
        return rounded</span>
}

func countDecimalPlaces(val float64) int <span class="cov8" title="1">{
        str := strconv.FormatFloat(val, 'f', -1, 64)
        parts := strings.Split(str, ".")
        if len(parts) == 2 </span><span class="cov8" title="1">{
                return len(parts[1])
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func truncateDecimal(val float64, decimalPlaces int) float64 <span class="cov8" title="1">{
        shift := math.Pow(10, float64(decimalPlaces))
        truncated := math.Floor(val*shift) / shift

        return truncated
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package atmcs

import (
        "errors"
        "fmt"
        "log"
        "math"
        "time"

        cpr "github.com/dragonzurfer/strategy/CPR"
        "github.com/dragonzurfer/trader/executor"
)

func (obj *ATMcs) IsEntrySatisfied() bool <span class="cov8" title="1">{

        if err := obj.SetSignal(); err != nil </span><span class="cov0" title="0">{
                log.Println("IsEntrySatisfied() failed:", err.Error())
                return false
        }</span>
        <span class="cov8" title="1">obj.SetEntryStates()
        return obj.EntrySatisfied</span>
}

func (obj *ATMcs) SetSignal() error <span class="cov8" title="1">{
        minTargetPercent := obj.Settings.MinTargetPercent
        minSLPercent := obj.Settings.MinStopLossPercent
        currentDayCandles, previousDayCandle, err := obj.GetCandles()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error in SetSignal():%w", err)
        }</span>
        <span class="cov8" title="1">obj.SignalCPR = cpr.GetCPRSignal(minSLPercent, minTargetPercent, previousDayCandle, currentDayCandles)
        return nil</span>
}

func (obj *ATMcs) SetEntryStates() <span class="cov8" title="1">{
        if obj.SignalCPR.Signal == cpr.Neutral </span><span class="cov8" title="1">{
                obj.EntrySatisfied = false
                obj.Trade.TradeType = executor.Nuetral
                obj.Trade.TargetPrice = math.SmallestNonzeroFloat64
                obj.Trade.StopLossPrice = math.SmallestNonzeroFloat64
                return
        }</span>
        <span class="cov8" title="1">obj.EntrySatisfied = true
        obj.ExitSatisfied = false
        obj.Trade.TargetPrice = obj.SignalCPR.TargetPrice
        obj.Trade.StopLossPrice = obj.SignalCPR.StopLossPrice
        obj.Trade.EntryPrice = obj.SignalCPR.EntryPrice
        switch obj.SignalCPR.Signal </span>{
        case cpr.Buy:<span class="cov8" title="1">
                obj.Trade.TradeType = executor.Buy</span>
        case cpr.Sell:<span class="cov8" title="1">
                obj.Trade.TradeType = executor.Sell</span>
        }
}

func (obj *ATMcs) GetCandles() (cpr.CPRCandles, cpr.CPRCandles, error) <span class="cov8" title="1">{
        currentTime := obj.GetCurrentTime()
        previousDate := obj.GetPreviousNonWeekendNonHolidayDate(currentTime)
        currentDay5minCandles, err := obj.GetCurrentDayCandleData5minFyers(currentTime)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errors.New("error in GetCandles() current day 5min candle data: " + err.Error())
        }</span>
        <span class="cov8" title="1">previousDayCandles, err := obj.GetPreviousDayCandleDataFyers(previousDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errors.New("error in GetCandles() getting previous day candle data: " + err.Error())
        }</span>
        <span class="cov8" title="1">if currentDay5minCandles.GetCandlesLength() &lt; 1 </span><span class="cov0" title="0">{
                return nil, nil, errors.New("zero candles returned on 5minute data API call to broker")
        }</span>
        <span class="cov8" title="1">if previousDayCandles.GetCandlesLength() &lt; 1 </span><span class="cov0" title="0">{
                return nil, nil, errors.New("zero candles returned on 1Day data API call to broker")
        }</span>
        <span class="cov8" title="1">return currentDay5minCandles, previousDayCandles, nil</span>
}

func (obj *ATMcs) GetPreviousDayCandleDataFyers(previousDate time.Time) (cpr.CPRCandles, error) <span class="cov8" title="1">{
        from := time.Date(previousDate.Year(), previousDate.Month(), previousDate.Day(), 9, 15, 0, 0, obj.ISTLocation)
        to := time.Date(previousDate.Year(), previousDate.Month(), previousDate.Day(), 15, 30, 0, 0, obj.ISTLocation)
        candles, err := obj.Broker.GetCandles(obj.Symbol, from, to, executor.Day)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">cprCandles := NewCandleAdapter(candles)
        return cprCandles, err</span>
}

func (obj *ATMcs) GetCurrentDayCandleData5minFyers(currentTime time.Time) (cpr.CPRCandles, error) <span class="cov8" title="1">{
        from := time.Date(currentTime.Year(), currentTime.Month(), currentTime.Day(), 9, 15, 0, 0, obj.ISTLocation)
        to := currentTime
        candles, err := obj.Broker.GetCandles(obj.Symbol, from, to, executor.Minute5)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">cprCandles := NewCandleAdapter(candles)
        return cprCandles, nil</span>
}

type Holidays struct {
        HolidayDates []string `json:"holiday_dates"`
}

func isDateHoliday(date string, holidays *Holidays) bool <span class="cov8" title="1">{
        for _, holiday := range holidays.HolidayDates </span><span class="cov8" title="1">{
                if holiday == date </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func WasMarketOpen(date time.Time, holidays *Holidays) bool <span class="cov8" title="1">{
        loc, err := time.LoadLocation("Asia/Kolkata")
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Error loading location:", err)
                return false
        }</span>

        // Check if the date is a weekend (Saturday or Sunday)
        <span class="cov8" title="1">if date.Weekday() == time.Saturday || date.Weekday() == time.Sunday </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">dateString := date.In(loc).Format("2006-01-02")

        // Check if the date is a holiday
        if isDateHoliday(dateString, holidays) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

func (obj *ATMcs) GetPreviousNonWeekendNonHolidayDate(currentDate time.Time) time.Time <span class="cov8" title="1">{
        previousDate := currentDate.AddDate(0, 0, -1)
        for !WasMarketOpen(previousDate, &amp;obj.Holidays) </span><span class="cov0" title="0">{
                previousDate = previousDate.AddDate(0, 0, -1)
        }</span>
        <span class="cov8" title="1">return previousDate</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package atmcs

import (
        "errors"
        "fmt"
        "log"

        "github.com/dragonzurfer/trader/atmcs/trade"
        "github.com/dragonzurfer/trader/executor"
)

func (obj *ATMcs) ExitAccount() {<span class="cov0" title="0">}</span>

func (obj *ATMcs) ExitPaper() <span class="cov8" title="1">{
        if !obj.Trade.InTrade </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">exitPositions, err := obj.MakeExitPositions()
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err.Error())
                return
        }</span>

        // Clear the current trade
        <span class="cov8" title="1">obj.Trade.InTrade = false
        obj.Trade.ExitPositions = exitPositions
        obj.Trade.TimeOfExit = obj.GetCurrentTime()</span>
}

func (obj *ATMcs) MakeExitPositions() ([]trade.OptionPosition, error) <span class="cov8" title="1">{
        var exitPositions []trade.OptionPosition

        // Loop through the current entry positions and create corresponding exit positions
        for _, entryPosition := range obj.Trade.EntryPositions </span><span class="cov8" title="1">{
                position := entryPosition
                exitPosition, err := obj.MakePositionExit(position)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.New("failed to makeExitPositions():" + err.Error())
                }</span>
                <span class="cov8" title="1">exitPositions = append(exitPositions, exitPosition)</span>
        }

        <span class="cov8" title="1">return exitPositions, nil</span>
}

func (obj *ATMcs) MakePositionExit(entryPosition trade.OptionPosition) (trade.OptionPosition, error) <span class="cov8" title="1">{
        // Fetch the current market price for the option
        var depth []executor.MarketDepthLike
        var err error
        var exitPosition trade.OptionPosition
        if entryPosition.GetTradeType() == executor.Buy </span><span class="cov8" title="1">{
                depth, err = GetBids(obj.Broker, entryPosition)
        }</span> else<span class="cov8" title="1"> {
                depth, err = GetAsks(obj.Broker, entryPosition)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return exitPosition, errors.New("failed to MakeExitPosition():" + err.Error())
        }</span>

        <span class="cov8" title="1">currentPrice := obj.GetAvgMarketDepth(depth)
        if currentPrice == 0 </span><span class="cov0" title="0">{
                return exitPosition, fmt.Errorf("could not get exit price for %v", entryPosition.GetOptionSymbol())

        }</span>

        // Create a new option position with the current price and trade type reversed
        <span class="cov8" title="1">exitPosition = trade.OptionPosition{
                Option: trade.Option{
                        Strike:           entryPosition.GetStrike(),
                        Expiry:           entryPosition.GetExpiry(),
                        Type:             entryPosition.GetOptionType(),
                        Symbol:           entryPosition.GetOptionSymbol(),
                        UnderlyingSymbol: entryPosition.GetUnderlyingSymbol(),
                },
                TradeType: reverseTradeType(entryPosition.GetTradeType()),
                Price:     currentPrice,
                Quantity:  entryPosition.GetQuantity(),
        }

        return exitPosition, nil</span>
}

func reverseTradeType(tradeType executor.TradeType) executor.TradeType <span class="cov8" title="1">{
        if tradeType == executor.Buy </span><span class="cov8" title="1">{
                return executor.Sell
        }</span> else<span class="cov8" title="1"> if tradeType == executor.Sell </span><span class="cov8" title="1">{
                return executor.Buy
        }</span> else<span class="cov0" title="0"> {
                return executor.Nuetral
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package atmcs

func (obj *ATMcs) GetEntryMessage() string <span class="cov0" title="0">{
        return ""
}</span>

func (obj *ATMcs) GetExitMessage() string <span class="cov0" title="0">{
        return ""
}</span>

func (obj *ATMcs) GetTradeCSV() []string <span class="cov0" title="0">{
        return []string{""}
}</span>

func (obj *ATMcs) GetCSVTradeEntry() []string <span class="cov0" title="0">{
        return []string{""}
}</span>

func (obj *ATMcs) GetCSVTradeExit() []string <span class="cov0" title="0">{
        return []string{""}
}</span>

func (obj *ATMcs) GeTradeJSON() string <span class="cov0" title="0">{
        return ""
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package atmcs

import (
        "encoding/json"
        "fmt"
        "io/ioutil"
        "os"
        "path/filepath"
)

func (obj *ATMcs) LoadFromJSON() error <span class="cov8" title="1">{
        fullPath := filepath.Join(obj.Settings.TradeFilePath)

        // Open the file
        file, err := os.Open(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // Read the file into a byte slice
        bytes, err := ioutil.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Unmarshal the byte slice into the Trade object
        <span class="cov8" title="1">err = json.Unmarshal(bytes, &amp;obj.Trade)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (obj *ATMcs) LogTrade() error <span class="cov8" title="1">{
        // Convert the Trade object to a JSON string
        tradeJSON, err := json.MarshalIndent(obj.Trade, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to convert Trade object to JSON: %w", err)
        }</span>

        // Get the full path of the trade.json file
        <span class="cov8" title="1">fullPath := obj.TradeFilePath

        // Write the JSON string to the file
        err = ioutil.WriteFile(fullPath, tradeJSON, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write Trade object to JSON file: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (obj *ATMcs) InTrade() bool <span class="cov8" title="1">{
        return obj.Trade.InTrade
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package atmcs

import (
        "fmt"

        "github.com/dragonzurfer/trader/executor"
)

func (obj *ATMcs) UpdateSL() {<span class="cov0" title="0">

}</span>

func (obj *ATMcs) ExitOnTick(tickPrice float64) <span class="cov8" title="1">{
        if obj.InTrade() </span><span class="cov8" title="1">{
                obj.SetMinTrail(tickPrice)
                if obj.IsHitTickSL(tickPrice) </span><span class="cov8" title="1">{
                        obj.StopLossHitChan &lt;- true
                        obj.Trade.IsStopLossHit = true
                        obj.ExitSatisfied = true
                        obj.Trade.TimeOfExit = obj.GetCurrentTime()
                        return
                }</span>
                <span class="cov8" title="1">if obj.IsHitTickTarget(tickPrice) </span><span class="cov8" title="1">{
                        obj.TargetHitChan &lt;- true
                        obj.ExitSatisfied = true
                        obj.Trade.TimeOfExit = obj.GetCurrentTime()
                        return
                }</span>
        }
}

// will be called while creating broker object
func (obj *ATMcs) IsHitTickSL(tickPrice float64) bool <span class="cov8" title="1">{

        switch obj.Trade.TradeType </span>{
        case executor.Buy:<span class="cov8" title="1">
                return tickPrice &lt;= obj.Trade.StopLossPrice</span>
        case executor.Sell:<span class="cov8" title="1">
                return tickPrice &gt;= obj.Trade.StopLossPrice</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (obj *ATMcs) IsHitTickTarget(tickPrice float64) bool <span class="cov8" title="1">{
        switch obj.Trade.TradeType </span>{
        case executor.Buy:<span class="cov8" title="1">
                return tickPrice &gt;= obj.Trade.TargetPrice</span>
        case executor.Sell:<span class="cov8" title="1">
                return tickPrice &lt;= obj.Trade.TargetPrice</span>
        }
        <span class="cov0" title="0">fmt.Println(tickPrice, obj.Trade.TargetPrice)
        return false</span>
}

func (obj *ATMcs) SetMinTrail(tickPrice float64) <span class="cov8" title="1">{
        // Calculate the absolute price change as a percentage
        priceChangePercent := 0.0
        if obj.Trade.TradeType == executor.Buy </span><span class="cov8" title="1">{
                // For a buy trade, we want the current price to be higher
                if tickPrice &gt; obj.Trade.EntryPrice </span><span class="cov8" title="1">{
                        priceChangePercent = (tickPrice - obj.Trade.EntryPrice) / obj.Trade.EntryPrice * 100
                }</span>
        } else<span class="cov8" title="1"> if obj.Trade.TradeType == executor.Sell </span><span class="cov8" title="1">{
                // For a sell trade, we want the current price to be lower
                if tickPrice &lt; obj.Trade.EntryPrice </span><span class="cov8" title="1">{
                        priceChangePercent = (obj.Trade.EntryPrice - tickPrice) / obj.Trade.EntryPrice * 100
                }</span>
        }

        <span class="cov8" title="1">if priceChangePercent &gt;= obj.Settings.MinTrailPercent </span><span class="cov8" title="1">{
                if !obj.Trade.IsMinTrailHit </span><span class="cov0" title="0">{
                        obj.Trade.IsMinTrailHit = true
                        obj.Trade.StopLossPrice = obj.Trade.EntryPrice
                }</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
