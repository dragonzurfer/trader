
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>atmcs: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/dragonzurfer/trader/atmcs/atmcs.go (59.3%)</option>
				
				<option value="file1">github.com/dragonzurfer/trader/atmcs/candleadapter.go (87.5%)</option>
				
				<option value="file2">github.com/dragonzurfer/trader/atmcs/entry.go (81.6%)</option>
				
				<option value="file3">github.com/dragonzurfer/trader/atmcs/entrysatisfy.go (77.6%)</option>
				
				<option value="file4">github.com/dragonzurfer/trader/atmcs/exit.go (81.6%)</option>
				
				<option value="file5">github.com/dragonzurfer/trader/atmcs/housekeeping.go (0.0%)</option>
				
				<option value="file6">github.com/dragonzurfer/trader/atmcs/loadtradejson.go (0.0%)</option>
				
				<option value="file7">github.com/dragonzurfer/trader/atmcs/satisfyexit.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package atmcs

import (
        "encoding/json"
        "io/ioutil"
        "log"
        "time"

        cpr "github.com/dragonzurfer/strategy/CPR"
        "github.com/dragonzurfer/trader/atmcs/trade"
        "github.com/dragonzurfer/trader/executor"
)

type ATMcs struct {
        ISTLocation    *time.Location
        SignalCPR      cpr.Signal
        EntrySatisfied bool
        ExitSatisfied  bool
        Broker         executor.BrokerLike
        EntryMessage   string
        ExitMessage    string
        SleepDuration  time.Duration
        Trade          trade.Trade
        Settings
        SettingsFilesPath string
        GetCurrentTime    func() time.Time
        Holidays
}

type Settings struct {
        HolidayDatesFilePath string  `json:"holidays_file_path"`
        MinTrailPercent      float64 `json:"min_trail_percent"`
        MinTargetPercent     float64 `json:"min_target_percent"`
        MinStopLossPercent   float64 `json:"min_sl_percent"`
        TradeFilePath        string  `json:"tradeFilePath"`
        Quantity             int64   `json:"quantity"`
        StrikeDiff           float64 `json:"strikeDiff"`
        MinDaysToExpiry      int64   `json:"minDaysToExpiry"`
        Symbol               string  `json:"symbol"`
        TickSize             float64 `json:"tick_size"`
}

func (obj *ATMcs) loadSettingsFromFile() error <span class="cov8" title="1">{
        var settings Settings

        // Read the JSON file
        fileData, err := ioutil.ReadFile(obj.SettingsFilesPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Unmarshal the JSON data into the Settings struct
        <span class="cov8" title="1">err = json.Unmarshal(fileData, &amp;settings)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">obj.Settings = settings
        return nil</span>
}

func (obj *ATMcs) SetBroker(broker executor.BrokerLike) <span class="cov8" title="1">{
        obj.Broker = broker
}</span>

func (obj *ATMcs) SetTradeFilePath(filepath string) <span class="cov8" title="1">{
        obj.TradeFilePath = filepath
}</span>

func (obj *ATMcs) SetSettingsFilesPath(filepath string) <span class="cov8" title="1">{
        obj.SettingsFilesPath = filepath
}</span>

func (obj *ATMcs) InTradingWindow() bool <span class="cov0" title="0">{
        return true
}</span>

func (obj *ATMcs) InTrade() bool <span class="cov0" title="0">{
        return obj.Trade.InTrade
}</span>

func (obj *ATMcs) IsError() bool <span class="cov0" title="0">{
        return false
}</span>
func (obj *ATMcs) ReadErrors() []string <span class="cov0" title="0">{
        return []string{}
}</span>
func (obj *ATMcs) GetSleepDuration() time.Duration <span class="cov0" title="0">{
        return time.Minute
}</span>

func (obj *ATMcs) LoadLocation() error <span class="cov8" title="1">{
        istLocation, err := time.LoadLocation("Asia/Kolkata")
        obj.ISTLocation = istLocation
        return err
}</span>

func (obj *ATMcs) LoadHolidays() error <span class="cov8" title="1">{
        holidaysData, err := ioutil.ReadFile(obj.HolidayDatesFilePath)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Error reading holidays file:", err)
                return err
        }</span>

        <span class="cov8" title="1">var holidays Holidays
        err = json.Unmarshal(holidaysData, &amp;holidays)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Error unmarshaling holidays data:", err)
                return err
        }</span>
        <span class="cov8" title="1">obj.Holidays = holidays
        return nil</span>
}

func (obj *ATMcs) AccountTrade(executor.TradeType) {<span class="cov0" title="0">

}</span>

func (obj *ATMcs) GetTradeType() executor.TradeType <span class="cov0" title="0">{
        return obj.Trade.TradeType
}</span>

func New(settingsFilePath, tradeFilePath string, currentTimeFunc func() time.Time) *ATMcs <span class="cov8" title="1">{
        var obj ATMcs
        obj.SetSettingsFilesPath(settingsFilePath)

        if err := obj.loadSettingsFromFile(); err != nil </span><span class="cov0" title="0">{
                log.Println("SetSettingsFIlesPath(string) failed to load settings from", obj.SettingsFilesPath)
                return nil
        }</span>
        <span class="cov8" title="1">if err := obj.LoadHolidays(); err != nil </span><span class="cov0" title="0">{
                log.Printf("LoadHolidays() file from %+v:%v\n", obj.Settings.HolidayDatesFilePath, err.Error())
                return nil
        }</span>
        <span class="cov8" title="1">if err := obj.LoadLocation(); err != nil </span><span class="cov0" title="0">{
                log.Println("error loading ist location:", err.Error())
                return nil
        }</span>
        <span class="cov8" title="1">if obj.Settings.TickSize &lt;= 0 </span><span class="cov0" title="0">{
                log.Println("error loading tick size, cannot be &lt;= 0")
                return nil
        }</span>
        <span class="cov8" title="1">if obj.Settings.MinTargetPercent &lt; obj.Settings.MinTrailPercent </span><span class="cov0" title="0">{
                log.Println("min target cananot be lesser than min trail in settings")
                return nil
        }</span>
        <span class="cov8" title="1">obj.SetTradeFilePath(tradeFilePath)
        obj.GetCurrentTime = currentTimeFunc
        obj.EntrySatisfied = false
        obj.ExitSatisfied = false
        return &amp;obj</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package atmcs

import (
        "github.com/dragonzurfer/revclose"
        "github.com/dragonzurfer/trader/executor"
)

type CandleAdapter struct {
        candles []executor.CandleLike
}

type RevCandleAdapter struct {
        candle executor.CandleLike
}

func (rca *RevCandleAdapter) GetHigh() float64 <span class="cov8" title="1">{
        return rca.candle.GetHigh()
}</span>

func (rca *RevCandleAdapter) GetLow() float64 <span class="cov8" title="1">{
        return rca.candle.GetLow()
}</span>

func (rca *RevCandleAdapter) GetClose() float64 <span class="cov8" title="1">{
        return rca.candle.GetClose()
}</span>

func (rca *RevCandleAdapter) GetOpen() float64 <span class="cov0" title="0">{
        return rca.candle.GetOpen()
}</span>

func (rca *RevCandleAdapter) GetOHLC() (float64, float64, float64, float64) <span class="cov8" title="1">{
        return rca.candle.GetOpen(), rca.candle.GetHigh(), rca.candle.GetLow(), rca.candle.GetClose()
}</span>

func (ca *CandleAdapter) GetCandle(index int) revclose.RevCandle <span class="cov8" title="1">{
        return &amp;RevCandleAdapter{candle: ca.candles[index]}
}</span>

func (ca *CandleAdapter) GetCandlesLength() int <span class="cov8" title="1">{
        return len(ca.candles)
}</span>

func NewCandleAdapter(candles []executor.CandleLike) *CandleAdapter <span class="cov8" title="1">{
        return &amp;CandleAdapter{
                candles: candles,
        }
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package atmcs

import (
        "errors"
        "fmt"
        "log"
        "math"
        "strconv"
        "strings"
        "time"

        "github.com/dragonzurfer/trader/executor"
)

type Option struct {
        Expiry           time.Time           `json:"expiry"`
        Strike           float64             `json:"strike"`
        Type             executor.OptionType `json:"type"`
        Symbol           string              `json:"symbol"`
        UnderlyingSymbol string              `json:"underlying_symbol"`
}

type OptionPosition struct {
        Option
        Price     float64
        TradeType executor.TradeType
        Quantity  int64
}

func (op OptionPosition) GetTradeType() executor.TradeType <span class="cov8" title="1">{ return op.TradeType }</span>
func (op OptionPosition) GetPrice() float64                <span class="cov8" title="1">{ return op.Price }</span>
func (op OptionPosition) GetQuantity() int64               <span class="cov8" title="1">{ return op.Quantity }</span>

func (o Option) GetExpiry() time.Time               <span class="cov8" title="1">{ return o.Expiry }</span>
func (o Option) GetStrike() float64                 <span class="cov8" title="1">{ return o.Strike }</span>
func (o Option) GetOptionType() executor.OptionType <span class="cov8" title="1">{ return o.Type }</span>
func (o Option) GetOptionSymbol() string            <span class="cov8" title="1">{ return o.Symbol }</span>
func (o Option) GetUnderlyingSymbol() string        <span class="cov8" title="1">{ return o.UnderlyingSymbol }</span>

func (obj *ATMcs) PaperTrade(tradeType executor.TradeType) <span class="cov8" title="1">{
        obj.Trade.InTrade = true
        obj.Trade.EntryPositions = obj.makeEntryPositions(tradeType)
        obj.Trade.TimeOfEntry = obj.GetCurrentTime()
}</span>

func (obj *ATMcs) makeEntryPositions(tradeType executor.TradeType) []executor.OptionPositionLike <span class="cov8" title="1">{

        ltp, err := obj.Broker.GetLTP(obj.Symbol)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err.Error())
                return nil
        }</span>

        <span class="cov8" title="1">strike := GetNearest100ITMStrike(ltp, tradeType)

        expiries, err := obj.Broker.GetOptionExpiries(obj.Symbol)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err.Error())
                return nil
        }</span>

        <span class="cov8" title="1">sellExpiry, err := GetExpiry(obj.GetCurrentTime(), obj.MinDaysToExpiry, strike, expiries)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err.Error())
                return nil
        }</span>

        <span class="cov8" title="1">buyExpiry, err := GetMonthlyExpiryCalendarSpread(obj.GetCurrentTime(), sellExpiry.ExpiryDate, expiries)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err.Error())
                return nil
        }</span>

        <span class="cov8" title="1">symbol := obj.Symbol

        quantity := obj.Quantity
        var sellPosition, buyPosition OptionPosition
        var entryPositions []executor.OptionPositionLike
        if tradeType == executor.Buy </span><span class="cov8" title="1">{
                sellPosition = obj.MakeEntryPosition(symbol, strike, sellExpiry, executor.PutOption, executor.Sell, quantity)
                buyPosition = obj.MakeEntryPosition(symbol, strike, buyExpiry, executor.PutOption, executor.Buy, quantity/2)
        }</span> else<span class="cov8" title="1"> {
                sellPosition = obj.MakeEntryPosition(symbol, strike, sellExpiry, executor.CallOption, executor.Sell, quantity)
                buyPosition = obj.MakeEntryPosition(symbol, strike, buyExpiry, executor.CallOption, executor.Buy, quantity/2)
        }</span>
        <span class="cov8" title="1">bids, err := GetBids(obj.Broker, sellPosition)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err.Error())
                return nil
        }</span>
        <span class="cov8" title="1">asks, err := GetAsks(obj.Broker, buyPosition)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err.Error())
                return nil
        }</span>
        <span class="cov8" title="1">sellPosition.Price = obj.GetAvgMarketDepth(bids)
        buyPosition.Price = obj.GetAvgMarketDepth(asks)
        entryPositions = append(entryPositions, sellPosition, buyPosition)
        return entryPositions</span>
}

func (obj *ATMcs) MakeEntryPosition(symbol string, strike float64, expiry executor.Expiry, optionType executor.OptionType, tradeType executor.TradeType, quantity int64) OptionPosition <span class="cov8" title="1">{
        option := Option{
                Strike:           strike,
                Expiry:           expiry.ExpiryDate,
                Type:             optionType,
                Symbol:           obj.Symbol, //change to broker symbol
                UnderlyingSymbol: symbol,
        }
        optionPosition := OptionPosition{
                Option:    option,
                TradeType: tradeType,
                Quantity:  quantity,
        }
        return optionPosition
}</span>

func (obj *ATMcs) GetAvgMarketDepth(depth []executor.MarketDepthLike) float64 <span class="cov8" title="1">{
        if len(depth) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">total := 0.0
        totalVolumeOrders := 0.0
        for _, marketDepth := range depth </span><span class="cov8" title="1">{
                volumeOrders := float64(marketDepth.GetQuantity() * marketDepth.GetNumOfOrders())
                total += marketDepth.GetPrice() * volumeOrders
                totalVolumeOrders += volumeOrders
        }</span>

        <span class="cov8" title="1">if totalVolumeOrders == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">avgPrice := total / totalVolumeOrders
        roundedPrice := roundToNearest(avgPrice, obj.Settings.TickSize)
        if roundedPrice &lt; avgPrice </span><span class="cov8" title="1">{
                roundedPrice += obj.Settings.TickSize
        }</span>
        <span class="cov8" title="1">decimalPlaces := countDecimalPlaces(obj.Settings.TickSize)
        roundedPrice = truncateDecimal(roundedPrice, decimalPlaces)
        return roundedPrice</span>
}

func GetBids(broker executor.BrokerLike, pos OptionPosition) ([]executor.MarketDepthLike, error) <span class="cov8" title="1">{
        bid_aks, err := broker.GetMarketDepthOption(pos.Strike, pos.Expiry, pos.Type)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return bid_aks.GetBids(), err</span>
}

func GetAsks(broker executor.BrokerLike, pos OptionPosition) ([]executor.MarketDepthLike, error) <span class="cov8" title="1">{
        bid_aks, err := broker.GetMarketDepthOption(pos.Strike, pos.Expiry, pos.Type)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return bid_aks.GetAsks(), err</span>
}

func GetExpiry(currentTime time.Time, minDaysToExpiry int64, strike float64, expiries []executor.Expiry) (executor.Expiry, error) <span class="cov8" title="1">{
        var err error
        err = fmt.Errorf("could not find an expiry that has %v days to expiry", minDaysToExpiry)
        minDiff := int64(math.MaxInt64)
        var earliestExpiry executor.Expiry
        for _, expiry := range expiries </span><span class="cov8" title="1">{
                daysDiff := int64(expiry.ExpiryDate.Sub(currentTime).Hours() / 24)
                if daysDiff &gt;= minDaysToExpiry &amp;&amp; daysDiff &lt; minDiff </span><span class="cov8" title="1">{
                        minDiff = daysDiff
                        earliestExpiry = expiry
                        err = nil
                }</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("could not find an expiry that has %v days to expiry: found expiry(%v) with %v days to expiry", minDaysToExpiry, earliestExpiry, minDiff)
        }</span>

        <span class="cov8" title="1">return earliestExpiry, err</span>
}

func GetMonthlyExpiryCalendarSpread(currentTime time.Time, sellExpiry time.Time, expiries []executor.Expiry) (executor.Expiry, error) <span class="cov8" title="1">{
        currentYear, currentMonth := currentTime.Year(), currentTime.Month()

        var lastExpiryOfCurrentMonth executor.Expiry
        var lastExpiryOfNextMonth executor.Expiry
        var foundCurrentMonth, foundNextMonth bool

        nextMonth := currentMonth + 1
        nextYear := currentYear

        if nextMonth &gt; 12 </span><span class="cov8" title="1">{
                nextMonth = 1
                nextYear++
        }</span>
        <span class="cov8" title="1">for _, expiry := range expiries </span><span class="cov8" title="1">{
                if expiry.ExpiryDate.After(sellExpiry) </span><span class="cov8" title="1">{

                        expiryYear, expiryMonth := expiry.ExpiryDate.Year(), expiry.ExpiryDate.Month()

                        if expiryYear == currentYear &amp;&amp; expiryMonth == currentMonth </span><span class="cov8" title="1">{
                                lastExpiryOfCurrentMonth = expiry
                                foundCurrentMonth = true
                        }</span> else<span class="cov8" title="1"> if expiryYear == nextYear &amp;&amp; expiryMonth == nextMonth </span><span class="cov8" title="1">{
                                lastExpiryOfNextMonth = expiry
                                foundNextMonth = true
                        }</span> else<span class="cov0" title="0"> if expiryYear &gt; nextYear || (expiryYear == nextYear &amp;&amp; expiryMonth &gt; nextMonth) </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">if foundCurrentMonth </span><span class="cov8" title="1">{
                return lastExpiryOfCurrentMonth, nil
        }</span> else<span class="cov8" title="1"> if foundNextMonth </span><span class="cov8" title="1">{
                return lastExpiryOfNextMonth, nil
        }</span> else<span class="cov0" title="0"> {
                return executor.Expiry{}, errors.New("no suitable monthly expiry found")
        }</span>
}

func GetNearest100ITMStrike(ltp float64, tradeType executor.TradeType) float64 <span class="cov8" title="1">{
        closest100Multiple := roundToNearest(ltp, 100)

        switch tradeType </span>{
        case executor.Buy:<span class="cov8" title="1">
                if closest100Multiple &lt; ltp </span><span class="cov8" title="1">{
                        return closest100Multiple + 100
                }</span>
                <span class="cov0" title="0">return closest100Multiple</span>
        case executor.Sell:<span class="cov8" title="1">
                if closest100Multiple &gt; ltp </span><span class="cov0" title="0">{
                        return closest100Multiple - 100
                }</span>
                <span class="cov8" title="1">return closest100Multiple</span>
        }
        <span class="cov0" title="0">return closest100Multiple</span>
}

func roundToNearest(val, roundTo float64) float64 <span class="cov8" title="1">{
        if roundTo == 0 </span><span class="cov0" title="0">{
                return val
        }</span>
        <span class="cov8" title="1">rounded := roundTo * float64(int(val/roundTo))
        return rounded</span>
}

func countDecimalPlaces(val float64) int <span class="cov8" title="1">{
        str := strconv.FormatFloat(val, 'f', -1, 64)
        parts := strings.Split(str, ".")
        if len(parts) == 2 </span><span class="cov8" title="1">{
                return len(parts[1])
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func truncateDecimal(val float64, decimalPlaces int) float64 <span class="cov8" title="1">{
        shift := math.Pow(10, float64(decimalPlaces))
        truncated := math.Floor(val*shift) / shift

        return truncated
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package atmcs

import (
        "errors"
        "log"
        "math"
        "time"

        cpr "github.com/dragonzurfer/strategy/CPR"
        "github.com/dragonzurfer/trader/executor"
)

func (obj *ATMcs) IsEntrySatisfied() bool <span class="cov8" title="1">{
        minTargetPercent := obj.Settings.MinTargetPercent
        minSLPercent := obj.Settings.MinStopLossPercent
        currentDayCandles, previousDayCandle, err := obj.GetCandles()
        if err != nil </span><span class="cov0" title="0">{
                log.Println("error in IsEntrySatisfied():", err.Error())
                return false
        }</span>

        <span class="cov8" title="1">obj.SignalCPR = cpr.GetCPRSignal(minSLPercent, minTargetPercent, previousDayCandle, currentDayCandles)
        obj.SetEntryStates()
        return obj.EntrySatisfied</span>
}

func (obj *ATMcs) SetEntryStates() <span class="cov8" title="1">{
        if obj.SignalCPR.Signal == cpr.Neutral </span><span class="cov8" title="1">{
                obj.EntrySatisfied = false
                obj.Trade.TradeType = executor.Nuetral
                obj.Trade.TargetPrice = math.SmallestNonzeroFloat64
                obj.Trade.StopLossPrice = math.SmallestNonzeroFloat64
                return
        }</span>
        <span class="cov8" title="1">obj.EntrySatisfied = true
        obj.ExitSatisfied = false
        obj.Trade.TargetPrice = obj.SignalCPR.TargetPrice
        obj.Trade.StopLossPrice = obj.SignalCPR.StopLossPrice
        switch obj.SignalCPR.Signal </span>{
        case cpr.Buy:<span class="cov8" title="1">
                obj.Trade.TradeType = executor.Buy</span>
        case cpr.Sell:<span class="cov0" title="0">
                obj.Trade.TradeType = executor.Sell</span>
        }
}

func (obj *ATMcs) GetCandles() (cpr.CPRCandles, cpr.CPRCandles, error) <span class="cov8" title="1">{
        currentTime := obj.GetCurrentTime()
        previousDate := obj.GetPreviousNonWeekendNonHolidayDate(currentTime)
        currentDay5minCandles, err := obj.GetCurrentDayCandleData5minFyers(currentTime)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errors.New("error in GetCandles() current day 5min candle data: " + err.Error())
        }</span>
        <span class="cov8" title="1">previousDayCandles, err := obj.GetPreviousDayCandleDataFyers(previousDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errors.New("error in GetCandles() getting previous day candle data: " + err.Error())
        }</span>
        <span class="cov8" title="1">if currentDay5minCandles.GetCandlesLength() &lt; 1 </span><span class="cov0" title="0">{
                return nil, nil, errors.New("zero candles returned on 5minute data API call to broker")
        }</span>
        <span class="cov8" title="1">if previousDayCandles.GetCandlesLength() &lt; 1 </span><span class="cov0" title="0">{
                return nil, nil, errors.New("zero candles returned on 1Day data API call to broker")
        }</span>
        <span class="cov8" title="1">return currentDay5minCandles, previousDayCandles, nil</span>
}

func (obj *ATMcs) GetPreviousDayCandleDataFyers(previousDate time.Time) (cpr.CPRCandles, error) <span class="cov8" title="1">{
        from := time.Date(previousDate.Year(), previousDate.Month(), previousDate.Day(), 9, 15, 0, 0, obj.ISTLocation)
        to := time.Date(previousDate.Year(), previousDate.Month(), previousDate.Day(), 15, 30, 0, 0, obj.ISTLocation)
        candles, err := obj.Broker.GetCandles(obj.Symbol, from, to, executor.Day)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">cprCandles := NewCandleAdapter(candles)
        return cprCandles, err</span>
}

func (obj *ATMcs) GetCurrentDayCandleData5minFyers(currentTime time.Time) (cpr.CPRCandles, error) <span class="cov8" title="1">{
        from := time.Date(currentTime.Year(), currentTime.Month(), currentTime.Day(), 9, 15, 0, 0, obj.ISTLocation)
        to := currentTime
        candles, err := obj.Broker.GetCandles(obj.Symbol, from, to, executor.Minute5)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">cprCandles := NewCandleAdapter(candles)
        return cprCandles, nil</span>
}

type Holidays struct {
        HolidayDates []string `json:"holiday_dates"`
}

func isDateHoliday(date string, holidays *Holidays) bool <span class="cov8" title="1">{
        for _, holiday := range holidays.HolidayDates </span><span class="cov8" title="1">{
                if holiday == date </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func WasMarketOpen(date time.Time, holidays *Holidays) bool <span class="cov8" title="1">{
        loc, err := time.LoadLocation("Asia/Kolkata")
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Error loading location:", err)
                return false
        }</span>

        // Check if the date is a weekend (Saturday or Sunday)
        <span class="cov8" title="1">if date.Weekday() == time.Saturday || date.Weekday() == time.Sunday </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">dateString := date.In(loc).Format("2006-01-02")

        // Check if the date is a holiday
        if isDateHoliday(dateString, holidays) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

func (obj *ATMcs) GetPreviousNonWeekendNonHolidayDate(currentDate time.Time) time.Time <span class="cov8" title="1">{
        previousDate := currentDate.AddDate(0, 0, -1)
        for !WasMarketOpen(previousDate, &amp;obj.Holidays) </span><span class="cov0" title="0">{
                previousDate = previousDate.AddDate(0, 0, -1)
        }</span>
        <span class="cov8" title="1">return previousDate</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package atmcs

import (
        "errors"
        "fmt"
        "log"

        "github.com/dragonzurfer/trader/executor"
)

func (obj *ATMcs) ExitAccount() {<span class="cov0" title="0">}</span>

func (obj *ATMcs) ExitPaper() <span class="cov8" title="1">{
        if !obj.Trade.InTrade </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">exitPositions, err := obj.MakeExitPositions()
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err.Error())
                return
        }</span>

        // Clear the current trade
        <span class="cov8" title="1">obj.Trade.InTrade = false
        exitPositionsLike := make([]executor.OptionPositionLike, len(exitPositions))
        for i, position := range exitPositions </span><span class="cov8" title="1">{
                exitPositionsLike[i] = position
        }</span>
        <span class="cov8" title="1">obj.Trade.ExitPositions = exitPositionsLike
        obj.Trade.TimeOfExit = obj.GetCurrentTime()</span>
}

func (obj *ATMcs) MakeExitPositions() ([]OptionPosition, error) <span class="cov8" title="1">{
        var exitPositions []OptionPosition

        // Loop through the current entry positions and create corresponding exit positions
        for _, entryPosition := range obj.Trade.EntryPositions </span><span class="cov8" title="1">{
                position := entryPosition.(OptionPosition)
                exitPosition, err := obj.MakePositionExit(position)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.New("failed to makeExitPositions():" + err.Error())
                }</span>
                <span class="cov8" title="1">exitPositions = append(exitPositions, exitPosition)</span>
        }

        <span class="cov8" title="1">return exitPositions, nil</span>
}

func (obj *ATMcs) MakePositionExit(entryPosition OptionPosition) (OptionPosition, error) <span class="cov8" title="1">{
        // Fetch the current market price for the option
        var depth []executor.MarketDepthLike
        var err error
        var exitPosition OptionPosition
        if entryPosition.GetTradeType() == executor.Buy </span><span class="cov8" title="1">{
                depth, err = GetBids(obj.Broker, entryPosition)
        }</span> else<span class="cov8" title="1"> {
                depth, err = GetAsks(obj.Broker, entryPosition)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return exitPosition, errors.New("failed to MakeExitPosition():" + err.Error())
        }</span>

        <span class="cov8" title="1">currentPrice := obj.GetAvgMarketDepth(depth)
        if currentPrice == 0 </span><span class="cov0" title="0">{
                return exitPosition, fmt.Errorf("could not get exit price for %v", entryPosition.GetOptionSymbol())

        }</span>

        // Create a new option position with the current price and trade type reversed
        <span class="cov8" title="1">exitPosition = OptionPosition{
                Option: Option{
                        Strike:           entryPosition.GetStrike(),
                        Expiry:           entryPosition.GetExpiry(),
                        Type:             entryPosition.GetOptionType(),
                        Symbol:           entryPosition.GetOptionSymbol(),
                        UnderlyingSymbol: entryPosition.GetUnderlyingSymbol(),
                },
                TradeType: reverseTradeType(entryPosition.GetTradeType()),
                Price:     currentPrice,
                Quantity:  entryPosition.GetQuantity(),
        }

        return exitPosition, nil</span>
}

func reverseTradeType(tradeType executor.TradeType) executor.TradeType <span class="cov8" title="1">{
        if tradeType == executor.Buy </span><span class="cov8" title="1">{
                return executor.Sell
        }</span> else<span class="cov8" title="1"> if tradeType == executor.Sell </span><span class="cov8" title="1">{
                return executor.Buy
        }</span> else<span class="cov0" title="0"> {
                return executor.Nuetral
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package atmcs

func (obj *ATMcs) GetEntryMessage() string <span class="cov0" title="0">{
        return ""
}</span>

func (obj *ATMcs) GetExitMessage() string <span class="cov0" title="0">{
        return ""
}</span>

func (obj *ATMcs) GetTradeCSV() []string <span class="cov0" title="0">{
        return []string{""}
}</span>

func (obj *ATMcs) GetCSVTradeEntry() []string <span class="cov0" title="0">{
        return []string{""}
}</span>

func (obj *ATMcs) GetCSVTradeExit() []string <span class="cov0" title="0">{
        return []string{""}
}</span>

func (obj *ATMcs) GeTradeJSON() string <span class="cov0" title="0">{
        return ""
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package atmcs

func (obj *ATMcs) LoadTradeFromJSON() {<span class="cov0" title="0">
        // loads from obj.Settings.TradeFilePath/trade.json
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package atmcs

func (obj *ATMcs) IsExitSatisfied() bool <span class="cov0" title="0">{
        // InTrade Check()? Error if not in trade
        // check if SL hit tick and close(pass candles post entryTime)
        // isMinTrail
        // update SL - Trail SL to entry on 1:1(min_trail_percent)-&gt; Traili SL to
        return false
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
